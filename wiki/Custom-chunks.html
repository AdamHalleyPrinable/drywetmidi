<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title> | DryWetMIDI </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content=" | DryWetMIDI ">
    <meta name="generator" content="docfx 2.51.0.0">
    
    <link rel="shortcut icon" href="../images/favicon.png">
    <link rel="stylesheet" href="../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../styles/docfx.css">
    <link rel="stylesheet" href="../styles/main.css">
    <meta property="docfx:navrel" content="../toc.html">
    <meta property="docfx:tocrel" content="toc.html">
    
    <meta property="docfx:rel" content="../">
    
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../index.html">
                <img id="logo" class="svg" src="../images/logo.png" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div class="container body-content">
        
        <div id="search-results">
          <div class="search-list"></div>
          <div class="sr-items">
            <p><i class="glyphicon glyphicon-refresh index-loading"></i></p>
          </div>
          <ul id="pagination"></ul>
        </div>
      </div>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">

<p>MIDI files are made up of <em>chunks</em>. Each chunk has a 4-character ID and a 32-bit length, which is the
number of bytes in the chunk. This structure allows future or custom chunk types to be designed which may be easily be
ignored if encountered by a program written before the chunk type is introduced or if the program doesn't know about the type. DryWetMIDI allows you to implement custom chunks which can be written to a MIDI file and be read from it.</p>
<p>For example, we want to design a chunk that will contain information about changes in a MIDI file. A change is described by date (day, month, year) and comment. Let's create the class to store single change.</p>
<pre><code class="lang-csharp">public sealed class Change
{
    public Change(DateTime date, string comment)
    {
        Date = date;
        Comment = comment;
    }

    public DateTime Date { get; }

    public string Comment { get; }
}
</code></pre>
<p>Now we are going to implement a custom chunk. Custom chunk class must be derived from the <code>MidiChunk</code> and must implement three abstract protected methods:</p>
<ul>
<li><code>ReadContent</code>;</li>
<li><code>WriteContent</code>;</li>
<li><code>GetContentSize</code>.</li>
</ul>
<p>Also the class must have parameterless constructor which calls constructor of the base class (<code>MidiChunk</code>) passing chunk's ID to it. ID is a 4-character string which is <em>Hstr</em> for our chunk. The class will look like this:</p>
<pre><code class="lang-csharp">public sealed class HistoryChunk : MidiChunk
{
    private const string Id = &quot;Hstr&quot;;

    private readonly List&lt;Change&gt; _changes = new List&lt;Change&gt;();

    public HistoryChunk()
        : base(Id)
    {
    }

    public void AddChange(DateTime dateTime, string comment)
    {
        _changes.Add(new Change(dateTime, comment));
    }

    protected override void ReadContent(MidiReader reader, ReadingSettings settings, uint size)
    {
        throw new NotImplementedException();
    }

    protected override void WriteContent(MidiWriter writer, WritingSettings settings)
    {
        throw new NotImplementedException();
    }

    protected override uint GetContentSize(WritingSettings settings)
    {
        throw new NotImplementedException();
    }
}
</code></pre>
<p>Before we will start to implement three methods mentioned above we need to determine the format in which changes have to be read and be written. Chunk's content will be started with a count of changes represented by <a href="https://en.wikipedia.org/wiki/Variable-length_quantity">variable-length quantity</a> (VLQ) number. The count followed by changes. Each change is represented by:</p>
<ul>
<li>one byte for day;</li>
<li>one byte for month;</li>
<li>two bytes for year;</li>
<li>VLQ number for size of bytes array representing comment;</li>
<li>bytes which represent comment.</li>
</ul>
<p>To store comments we will use <code>Encoding.Unicode</code>.</p>
<p>Let's implement the <code>ReadContent</code> method:</p>
<pre><code class="lang-csharp">protected override void ReadContent(MidiReader reader, ReadingSettings settings, uint size)
{
    // Read changes count

    var changesCount = reader.ReadVlqNumber();

    for (int i = 0; i &lt; changesCount; i++)
    {
        // Read date

        var day = reader.ReadByte();
        var month = reader.ReadByte();
        var year = reader.ReadWord(); // two byte unsigned integer

        // Read comment

        var commentLength = reader.ReadVlqNumber();
        var commentBytes = reader.ReadBytes(commentLength);
        var comment = Encoding.Unicode.GetString(commentBytes);

        // Add read change to changes list

        AddChange(new DateTime(year, month, day), comment);
    }
}
</code></pre>
<p>It is highly recommended that count of the bytes were read by this method will be equal to the value passed to <em>size</em> parameter.</p>
<p>To be able to write the chunk we need to implement <code>WriteContent</code> method:</p>
<pre><code class="lang-csharp">protected override void WriteContent(MidiWriter writer, WritingSettings settings)
{
    // Write changes count

    writer.WriteVlqNumber(_changes.Count);

    foreach (var change in _changes)
    {
        // Write date

        var date = change.Date;
        writer.WriteByte((byte)date.Day);
        writer.WriteByte((byte)date.Month);
        writer.WriteWord((ushort)date.Year);

        // Write comment

        var comment = change.Comment;
        if (string.IsNullOrEmpty(comment))
        {
            writer.WriteVlqNumber(0);
            continue;
        }

        var commentBytes = Encoding.Unicode.GetBytes(comment.ToCharArray());
        writer.WriteVlqNumber(commentBytes.Length);
        writer.WriteBytes(commentBytes);
    }
}
</code></pre>
<p>Every chunk starts with ID and its size. DryWetMIDI calls <code>GetContentSize</code> method of the <code>Chunk</code> to write its return value as chunk's size. You must calculate real size of the chunk's content in order to programs which will be read a MIDI file with your custom chunk will be able to skip it by advancing position of the reader on this size. Let's implement <code>GetContentSize</code>:</p>
<pre><code class="lang-csharp">protected override uint GetContentSize(WritingSettings settings)
{
    return (uint)(_changes.Count.GetVlqLength() +
                  _changes.Select(c =&gt;
                                  {
                                      var commentLength = Encoding.Unicode.GetByteCount(c.Comment.ToCharArray());
                                      return 4 // 1 for day, 1 for month, 2 for year
                                             + commentLength.GetVlqLength() + commentLength;
                                  })
                          .DefaultIfEmpty()
                          .Sum());
}
</code></pre>
<p>That's all! Custom chunk is completely implemented. See code sample below to know how to read and write it:</p>
<pre><code class="lang-csharp">
// Create a history chunk and populate it by some changes

var historyChunk = new HistoryChunk();
historyChunk.AddChange(new DateTime(2017, 3, 23), &quot;Start the history!&quot;);
historyChunk.AddChange(new DateTime(2156, 11, 3), &quot;Comment from the future.&quot;);
historyChunk.AddChange(new DateTime(9999, 2, 12), null);

// Add the chunk to an existing MIDI file

var file = MidiFile.Read(&quot;My Great Song.mid&quot;);
file.Chunks.Add(historyChunk);
file.Write(&quot;My Great Song.mid&quot;, true);

// Read the file with our chunk

var fileWithHistory = MidiFile.Read(&quot;My Great Song.mid&quot;,
                                    new ReadingSettings
                                    {
                                        CustomChunksTypes = new ChunkTypesCollection
                                        {
                                            { typeof(HistoryChunk), &quot;Hstr&quot; }
                                        }
                                    });
</code></pre>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              <!-- <p><a class="back-to-top" href="#top">Back to top</a><p> -->
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            Generated by <b>DocFX</b> on March 20, 2020 14:48:50
            
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../styles/docfx.js"></script>
    <script type="text/javascript" src="../styles/main.js"></script>
  </body>
</html>
